<!DOCTYPE html>
<html>

<head>
    <meta charset=utf-8>
    <title>My first three.js app</title>
    <label type="text">IMAGE:</label>
    <input type="text" id="imageInput" />
    <Button id="submit" type="button">SUBMIT SETTINGS</Button>
    <style>
        body { margin: 0;
               overflow: hidden;
        }
        canvas { width: 100%; ]
                 height: 100%
                }
    </style>
</head>


<body>


<canvas id="myCanvas"></canvas>

<script src = "js/ObjectControls.js"></script>
<script src = "js/three.js"> </script>
<script>

    /*
 * @author zz85 / https://github.com/zz85
 * @author mrdoob / http://mrdoob.com
 * Running this will allow you to drag three.js objects around the screen.
 */

    THREE.DragControls = function ( _objects, _camera, _domElement ) {

        if ( _objects instanceof THREE.Camera ) {

            console.warn( 'THREE.DragControls: Constructor now expects ( objects, camera, domElement )' );
            var temp = _objects; _objects = _camera; _camera = temp;

        }

        var _plane = new THREE.Plane();
        var _raycaster = new THREE.Raycaster();

        var _mouse = new THREE.Vector2();
        var _offset = new THREE.Vector3();
        var _intersection = new THREE.Vector3();

        var _selected = null, _hovered = null;

        //

        var scope = this;

        function activate() {

            _domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
            _domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
            _domElement.addEventListener( 'mouseup', onDocumentMouseCancel, false );
            _domElement.addEventListener( 'mouseleave', onDocumentMouseCancel, false );
            _domElement.addEventListener( 'touchmove', onDocumentTouchMove, false );
            _domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
            _domElement.addEventListener( 'touchend', onDocumentTouchEnd, false );

        }

        function deactivate() {

            _domElement.removeEventListener( 'mousemove', onDocumentMouseMove, false );
            _domElement.removeEventListener( 'mousedown', onDocumentMouseDown, false );
            _domElement.removeEventListener( 'mouseup', onDocumentMouseCancel, false );
            _domElement.removeEventListener( 'mouseleave', onDocumentMouseCancel, false );
            _domElement.removeEventListener( 'touchmove', onDocumentTouchMove, false );
            _domElement.removeEventListener( 'touchstart', onDocumentTouchStart, false );
            _domElement.removeEventListener( 'touchend', onDocumentTouchEnd, false );

        }

        function dispose() {

            deactivate();

        }

        function onDocumentMouseMove( event ) {

            event.preventDefault();

            var rect = _domElement.getBoundingClientRect();

            _mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
            _mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

            _raycaster.setFromCamera( _mouse, _camera );

            if ( _selected && scope.enabled ) {

                if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

                    _selected.position.copy( _intersection.sub( _offset ) );

                }

                scope.dispatchEvent( { type: 'drag', object: _selected } );

                return;

            }

            _raycaster.setFromCamera( _mouse, _camera );

            var intersects = _raycaster.intersectObjects( _objects );

            if ( intersects.length > 0 ) {

                var object = intersects[ 0 ].object;

                _plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), object.position );

                if ( _hovered !== object ) {

                    scope.dispatchEvent( { type: 'hoveron', object: object } );

                    _domElement.style.cursor = 'pointer';
                    _hovered = object;

                }

            } else {

                if ( _hovered !== null ) {

                    scope.dispatchEvent( { type: 'hoveroff', object: _hovered } );

                    _domElement.style.cursor = 'auto';
                    _hovered = null;

                }

            }

        }

        function onDocumentMouseDown( event ) {

            event.preventDefault();

            _raycaster.setFromCamera( _mouse, _camera );

            var intersects = _raycaster.intersectObjects( _objects );

            if ( intersects.length > 0 ) {

                _selected = intersects[ 0 ].object;

                if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

                    _offset.copy( _intersection ).sub( _selected.position );

                }

                _domElement.style.cursor = 'move';

                scope.dispatchEvent( { type: 'dragstart', object: _selected } );

            }


        }

        function onDocumentMouseCancel( event ) {

            event.preventDefault();

            if ( _selected ) {

                scope.dispatchEvent( { type: 'dragend', object: _selected } );

                _selected = null;

            }

            _domElement.style.cursor = 'auto';

        }

        function onDocumentTouchMove( event ) {

            event.preventDefault();
            event = event.changedTouches[ 0 ];

            var rect = _domElement.getBoundingClientRect();

            _mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
            _mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

            _raycaster.setFromCamera( _mouse, _camera );

            if ( _selected && scope.enabled ) {

                if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

                    _selected.position.copy( _intersection.sub( _offset ) );

                }

                scope.dispatchEvent( { type: 'drag', object: _selected } );



            }

        }

        function onDocumentTouchStart( event ) {

            event.preventDefault();
            event = event.changedTouches[ 0 ];

            var rect = _domElement.getBoundingClientRect();

            _mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
            _mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

            _raycaster.setFromCamera( _mouse, _camera );

            var intersects = _raycaster.intersectObjects( _objects );

            if ( intersects.length > 0 ) {

                _selected = intersects[ 0 ].object;

                _plane.setFromNormalAndCoplanarPoint( _camera.getWorldDirection( _plane.normal ), _selected.position );

                if ( _raycaster.ray.intersectPlane( _plane, _intersection ) ) {

                    _offset.copy( _intersection ).sub( _selected.position );

                }

                _domElement.style.cursor = 'move';

                scope.dispatchEvent( { type: 'dragstart', object: _selected } );

            }


        }

        function onDocumentTouchEnd( event ) {

            event.preventDefault();

            if ( _selected ) {

                scope.dispatchEvent( { type: 'dragend', object: _selected } );

                _selected = null;

            }

            _domElement.style.cursor = 'auto';

        }

        activate();

        // API

        this.enabled = true;

        this.activate = activate;
        this.deactivate = deactivate;
        this.dispose = dispose;

        // Backward compatibility

        this.setObjects = function () {

            console.error( 'THREE.DragControls: setObjects() has been removed.' );

        };

        this.on = function ( type, listener ) {

            console.warn( 'THREE.DragControls: on() has been deprecated. Use addEventListener() instead.' );
            scope.addEventListener( type, listener );

        };

        this.off = function ( type, listener ) {

            console.warn( 'THREE.DragControls: off() has been deprecated. Use removeEventListener() instead.' );
            scope.removeEventListener( type, listener );

        };

        this.notify = function ( type ) {

            console.error( 'THREE.DragControls: notify() has been deprecated. Use dispatchEvent() instead.' );
            scope.dispatchEvent( { type: type } );

        };

    };

    THREE.DragControls.prototype = Object.create( THREE.EventDispatcher.prototype );
    THREE.DragControls.prototype.constructor = THREE.DragControls;



/* authors: Nicholas Charles, Zack Brandon,
            David Reedy, Landry LastName
 */
















    document.getElementById('submit').onclick = function(){


        var imageURL = document.getElementById('imageInput');
        var myURL = imageURL.value;




        var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas'), antialias: true});
        //renderer.setClearColor(0xf0f0f0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);



       var camera = new THREE.OrthographicCamera( innerWidth / - 2, innerWidth / 2, innerHeight / 2, innerHeight / - 2, 0.1, 3000 );
        camera.position.set(0, 0, 0);


        var scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xf0f0f0 );
        scene.add(camera);


        var canvas = document.getElementById('myCanvas');

        document.body.appendChild( renderer.domElement );

        const textureLoader = new THREE.TextureLoader();
        textureLoader.crossOrigin = "Anonymous";
        const myTexture = textureLoader.load(myURL);

        var objects = [];

        var start = new THREE.BoxGeometry(innerWidth / 2, innerHeight / 2, 2);
        var grid = new THREE.Mesh(start, new THREE.MeshBasicMaterial({color: 0x000000}));
        grid.position.set(((innerWidth / 2) * -1) + 400, innerHeight / 2 - 200, -1010);
        scene.add(grid);


        var innerGridGeo = new THREE.BoxGeometry(innerWidth / 2.05, innerHeight / 2.1, 2);
        var innerGrid = new THREE.Mesh(innerGridGeo, new THREE.MeshBasicMaterial({color:0xf0f0f0}));
        innerGrid.position.set(((innerWidth / 2) * -1) + 400, innerHeight / 2 - 200, -1005);
        scene.add(innerGrid);

        var geometry = new THREE.BoxGeometry(50, 50, 2);
        for (var i = 0; i< 100; i++){


            var cube = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff}));

            cube.position.x = Math.random() * (window.innerWidth / 3) + 200;
            cube.position.y = -1 * Math.random() * (window.innerHeight  / 2) + 100;
            cube.position.z = -1000;

            scene.add(cube);

            objects.push(cube);

        }

        function render(){
            renderer.render(scene, camera);
        }

        

        const dragControls = new THREE.DragControls(objects, camera, renderer.domElement);

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();




    }







</script>
</body>







</html>
